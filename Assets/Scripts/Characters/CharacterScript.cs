using UnityEngine;

public class CharacterScript : MonoBehaviour
{
    public float speed = 3.0f;
    public float jumpSpeed = 10.0f;
    public LayerMask ground;
    public int MaxHealth = 100;

    private int currentHealth = 100;

    Rigidbody2D rigidbody2d;
    Animator animator;
    new Collider2D collider;

    public float InvincibleTime = 2.0f;
    bool isInvincible;
    float invincibleTimer;

    enum State
    {
        IDLE = 0,
        RUNNING = 1,
        JUMPING = 2,
        FALLING = 3,
    }

    State state = State.IDLE;

    

    // Start is called before the first frame update
    void Start()
    {
        rigidbody2d = GetComponent<Rigidbody2D>();
        animator = GetComponent<Animator>();
        collider = GetComponent<Collider2D>();
        state = State.IDLE;
        currentHealth = MaxHealth;
    }

    // Update is called once per frame
    void Update()
    {
        if (isInvincible)
        {
            invincibleTimer -= Time.deltaTime;
            if (invincibleTimer < 0)
            {
                isInvincible = false;
            }
        }

        if (Input.GetKey(KeyCode.A))
        {
            transform.localScale = new Vector2(-1, 1);
            rigidbody2d.velocity = new Vector2(-speed, rigidbody2d.velocity.y);
        }
        
        if (Input.GetKey(KeyCode.D))
        {
            transform.localScale = new Vector2(1, 1);
            rigidbody2d.velocity = new Vector2(speed, rigidbody2d.velocity.y);
        }

        if (Input.GetKeyUp(KeyCode.A) || Input.GetKeyUp(KeyCode.D))
        {
            rigidbody2d.velocity = new Vector2(0.0f, rigidbody2d.velocity.y);
        }

        if (Input.GetKeyDown(KeyCode.Space) && collider.IsTouchingLayers(ground))
        {
            rigidbody2d.velocity = new Vector2(rigidbody2d.velocity.x, jumpSpeed);
            state = State.JUMPING;
        }

        if (Input.GetKeyDown(KeyCode.Mouse0))
        {
            animator.SetTrigger("attack");

        }

        if (Input.GetKeyDown(KeyCode.C))
        {
            ChangeHealth(-1);
        }

        checkVelocityState();
        animator.SetInteger("state", (int)state);
    }

    private void checkVelocityState()
    {
        if (state == State.JUMPING)
        {
            if (rigidbody2d.velocity.y < -0.2f)
            {
                state = State.FALLING;
            }
        }
        else if (state == State.FALLING)
        {
            if (collider.IsTouchingLayers(ground))
            {
                state = State.IDLE;
            }
        }
        else if (rigidbody2d.velocity.y < -jumpSpeed)
        {
            Debug.Log(rigidbody2d.velocity.y);
            state = State.FALLING;
        }
        else if (Mathf.Abs(rigidbody2d.velocity.x) > 2f)
        {
            state = State.RUNNING;
        }
        else
        {
            state = State.IDLE;
        }
    }

    public void ChangeHealth(int amount)
    {
        if (amount < 0)
        {
            if (isInvincible)
            {
                return;
            }
            animator.SetTrigger("hit");
            isInvincible = true;
            invincibleTimer = InvincibleTime;
        }



        currentHealth = Mathf.Clamp(currentHealth + amount, 0, MaxHealth);

        Debug.Log(currentHealth);

    }


    /// <summary>
    /// Physics related code down here, logic should be above this part
    /// </summary>

    bool isGrounded; // Handy to have for jumping, and we'll use it here too
    Vector2 counterGravity; // Just holds some data for us...
    ContactPoint2D[] cPoints; // ContactPoints are generated by Collision, and they hold lots of fun data.
    public float maxGroundedAngle = 45f; //The steepest you want the character to be able to stand firmly on. Steeper than this and they'll slide.
    public float surfaceAngle;

    void OnCollisionStay2D(Collision2D ourCollision)
    {
        isGrounded = CheckGrounded(ourCollision);
    }

    void OnCollisionExit2D(Collision2D ourCollision)
    {
        /*It's okay to not have to check whether or not
         the Collision we're exiting is one we're grounded on,
         because it'll be reaffirmed next time OnCollisionStay runs.*/
        isGrounded = false;
    }

    bool CheckGrounded(Collision2D newCol)
    {
        cPoints = new ContactPoint2D[newCol.contactCount];
        newCol.GetContacts(cPoints);
        foreach (ContactPoint2D cP in cPoints)
        {
            /*If the difference in angle between the direction of gravity
              (usually, downward) and the current surface contacted is
              less than our chosen maximum angle, we've found an
              acceptable place to be grounded.*/
            if (maxGroundedAngle > Vector2.Angle(cP.normal, -Physics2D.gravity.normalized))
            {
                surfaceAngle = Vector2.Angle(cP.normal, -Physics2D.gravity.normalized);
                return true;
            }
        }
        return false;
    }

    void ObeyGravity()
    {
        if (isGrounded == true)
        {

            /*Not normal gravity. Instead of going down, we go in the
            direction perpendicular to the angle of where we're standing. 
            This means whatever surface we're grounded on will be 
            effectively the same as standing on a perfectly horizontal 
            surface. Ergo, no sliding will occur. */
            var mass = rigidbody2d.mass;
            var gravity = Physics2D.gravity.magnitude;
            counterGravity = new Vector2(Mathf.Sin(surfaceAngle) * (-1) * gravity *mass,
                Mathf.Cos(surfaceAngle) * (-1) * gravity * mass);
            Debug.Log(counterGravity);
        }
        rigidbody2d.AddForce(counterGravity, ForceMode2D.Force);
    }

    void FixedUpdate()
    {
        ObeyGravity();
    }
}
